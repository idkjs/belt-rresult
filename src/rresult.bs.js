// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var $$String = require("bs-platform/lib/js/string.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function ok(v) {
  return /* Ok */Block.__(0, [v]);
}

function error(e) {
  return /* Error */Block.__(1, [e]);
}

function get_ok(v) {
  if (v.tag) {
    return Pervasives.invalid_arg("result value is (Error _)");
  } else {
    return v[0];
  }
}

function get_error(e) {
  if (e.tag) {
    return e[0];
  } else {
    return Pervasives.invalid_arg("result value is (Ok _)");
  }
}

function reword_error(reword, r) {
  if (r.tag) {
    return /* Error */Block.__(1, [Curry._1(reword, r[0])]);
  } else {
    return r;
  }
}

function bind(v, f) {
  if (v.tag) {
    return v;
  } else {
    return Curry._1(f, v[0]);
  }
}

function map(f, v) {
  if (v.tag) {
    return v;
  } else {
    return /* Ok */Block.__(0, [Curry._1(f, v[0])]);
  }
}

function join(r) {
  if (r.tag) {
    return r;
  } else {
    return r[0];
  }
}

function $great$great$pipe(v, f) {
  if (v.tag) {
    return v;
  } else {
    return /* Ok */Block.__(0, [Curry._1(f, v[0])]);
  }
}

var Infix = {
  $great$great$eq: bind,
  $great$great$pipe: $great$great$pipe
};

function pp_lines(ppf, s) {
  var left = {
    contents: 0
  };
  var right = {
    contents: 0
  };
  var len = s.length;
  var flush = function (param) {
    Format.pp_print_string(ppf, $$String.sub(s, left.contents, right.contents - left.contents | 0));
    right.contents = right.contents + 1 | 0;
    left.contents = right.contents;
    
  };
  while(right.contents !== len) {
    if (Caml_string.get(s, right.contents) === /* "\n" */10) {
      flush(undefined);
      Format.pp_force_newline(ppf, undefined);
    } else {
      right.contents = right.contents + 1 | 0;
    }
  };
  if (left.contents !== len) {
    return flush(undefined);
  }
  
}

function msg(s) {
  return /* `Msg */[
          3854881,
          s
        ];
}

function msgf(fmt) {
  var kmsg = function (param) {
    return /* `Msg */[
            3854881,
            Format.flush_str_formatter(undefined)
          ];
  };
  return Format.kfprintf(kmsg, Format.str_formatter, fmt);
}

function pp_msg(ppf, param) {
  return pp_lines(ppf, param[1]);
}

function error_msg(s) {
  return /* Error */Block.__(1, [/* `Msg */[
              3854881,
              s
            ]]);
}

function error_msgf(fmt) {
  var kerr = function (param) {
    return /* Error */Block.__(1, [/* `Msg */[
                3854881,
                Format.flush_str_formatter(undefined)
              ]]);
  };
  return Format.kfprintf(kerr, Format.str_formatter, fmt);
}

function reword_error_msg(replaceOpt, reword, r) {
  var replace = replaceOpt !== undefined ? replaceOpt : false;
  if (!r.tag) {
    return r;
  }
  var e = r[0][1];
  var v = Curry._1(reword, e);
  if (replace) {
    return /* Error */Block.__(1, [v]);
  } else {
    return Curry._2(error_msgf(/* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */Block.__(12, [
                            /* "\n" */10,
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "%s\n%s"
                  ]), e, v[1]);
  }
}

function error_to_msg(pp_error, r) {
  if (r.tag) {
    return Curry._2(error_msgf(/* Format */[
                    /* Alpha */Block.__(15, [/* End_of_format */0]),
                    "%a"
                  ]), pp_error, r[0]);
  } else {
    return r;
  }
}

function error_msg_to_invalid_arg(v) {
  if (v.tag) {
    return Pervasives.invalid_arg(v[0][1]);
  } else {
    return v[0];
  }
}

function open_error_msg(r) {
  return r;
}

function failwith_error_msg(v) {
  if (v.tag) {
    return Pervasives.failwith(v[0][1]);
  } else {
    return v[0];
  }
}

function pp_exn_trap(ppf, param) {
  var match = param[1];
  Curry._1(Format.fprintf(ppf, /* Format */[
            /* String */Block.__(2, [
                /* No_padding */0,
                /* Formatting_lit */Block.__(17, [
                    /* Force_newline */3,
                    /* End_of_format */0
                  ])
              ]),
            "%s@\n"
          ]), Printexc.to_string(match[0]));
  return pp_lines(ppf, Printexc.raw_backtrace_to_string(match[1]));
}

function trap_exn(f, v) {
  try {
    return /* Ok */Block.__(0, [Curry._1(f, v)]);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    var bt = Printexc.get_raw_backtrace(undefined);
    return /* Error */Block.__(1, [/* `Exn_trap */[
                -469840015,
                /* tuple */[
                  e,
                  bt
                ]
              ]]);
  }
}

function error_exn_trap_to_msg(r) {
  if (r.tag) {
    return Curry._2(error_msgf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "Unexpected exception:",
                        /* Formatting_lit */Block.__(17, [
                            /* Force_newline */3,
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ])
                      ]),
                    "Unexpected exception:@\n%a"
                  ]), pp_exn_trap, r[0]);
  } else {
    return r;
  }
}

function open_error_exn_trap(r) {
  return r;
}

function pp(ok, error, ppf, v) {
  if (v.tag) {
    return Curry._2(error, ppf, v[0]);
  } else {
    return Curry._2(ok, ppf, v[0]);
  }
}

function dump(ok, error, ppf, v) {
  if (v.tag) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "Error",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<2>Error@ @[%a@]@]"
                  ]), error, v[0]);
  } else {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "Ok",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<2>Ok@ @[%a@]@]"
                  ]), ok, v[0]);
  }
}

function is_ok(param) {
  if (param.tag) {
    return false;
  } else {
    return true;
  }
}

function is_error(param) {
  if (param.tag) {
    return true;
  } else {
    return false;
  }
}

function equal(ok, error, r, r$prime) {
  if (r.tag) {
    if (r$prime.tag) {
      return Curry._2(error, r[0], r$prime[0]);
    } else {
      return false;
    }
  } else if (r$prime.tag) {
    return false;
  } else {
    return Curry._2(ok, r[0], r$prime[0]);
  }
}

function compare(ok, error, r, r$prime) {
  if (r.tag) {
    if (r$prime.tag) {
      return Curry._2(error, r[0], r$prime[0]);
    } else {
      return 1;
    }
  } else if (r$prime.tag) {
    return -1;
  } else {
    return Curry._2(ok, r[0], r$prime[0]);
  }
}

function to_option(v) {
  if (v.tag) {
    return ;
  } else {
    return Caml_option.some(v[0]);
  }
}

function of_option(none, v) {
  if (v !== undefined) {
    return /* Ok */Block.__(0, [Caml_option.valFromOption(v)]);
  } else {
    return Curry._1(none, undefined);
  }
}

function to_presult(v) {
  if (v.tag) {
    return /* `Error */[
            106380200,
            v[0]
          ];
  } else {
    return /* `Ok */[
            17724,
            v[0]
          ];
  }
}

function of_presult(param) {
  if (param[0] >= 106380200) {
    return /* Error */Block.__(1, [param[1]]);
  } else {
    return /* Ok */Block.__(0, [param[1]]);
  }
}

function ignore_error(use, v) {
  if (v.tag) {
    return Curry._1(use, v[0]);
  } else {
    return v[0];
  }
}

function kignore_error(use, r) {
  if (r.tag) {
    return Curry._1(use, r[0]);
  } else {
    return r;
  }
}

var $great$great$eq = bind;

var R = {
  ok: ok,
  error: error,
  reword_error: reword_error,
  get_ok: get_ok,
  get_error: get_error,
  $$return: ok,
  fail: error,
  bind: bind,
  map: map,
  join: join,
  $great$great$eq: bind,
  $great$great$pipe: $great$great$pipe,
  Infix: Infix,
  msg: msg,
  msgf: msgf,
  pp_msg: pp_msg,
  error_msg: error_msg,
  error_msgf: error_msgf,
  reword_error_msg: reword_error_msg,
  error_to_msg: error_to_msg,
  error_msg_to_invalid_arg: error_msg_to_invalid_arg,
  open_error_msg: open_error_msg,
  failwith_error_msg: failwith_error_msg,
  pp_exn_trap: pp_exn_trap,
  trap_exn: trap_exn,
  error_exn_trap_to_msg: error_exn_trap_to_msg,
  open_error_exn_trap: open_error_exn_trap,
  pp: pp,
  dump: dump,
  is_ok: is_ok,
  is_error: is_error,
  equal: equal,
  compare: compare,
  to_option: to_option,
  of_option: of_option,
  to_presult: to_presult,
  of_presult: of_presult,
  ignore_error: ignore_error,
  kignore_error: kignore_error
};

exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.R = R;
/* Format Not a pure module */
